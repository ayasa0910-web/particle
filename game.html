<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>シンプルなシューティングゲーム</title>
    <style>
        body {
            display: flex;
            flex-direction: column; /* 垂直方向に並べる */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        canvas {
            border: 2px solid #333;
            background-color: #000; /* ゲーム背景を黒に */
        }
        .controls {
            margin-top: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="640"></canvas>

<div class="controls">
    <button id="pauseButton">Pause / Resume (Enterキー)</button>
</div>

<script>
    // -----------------------------------------------------
    // 1. セットアップ
    // -----------------------------------------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const pauseButton = document.getElementById('pauseButton');

    // ゲーム変数
    let gameLoop;
    let isGameOver = false;
    let isPaused = false;

    // プレイヤー（自機）
    const player = {
        x: canvas.width / 2 - 25,
        y: canvas.height - 70,
        width: 50,
        height: 50,
        speed: 8
    };

    // 弾丸の配列
    let bullets = []; // 自機の弾
    let enemyBullets = []; // ★敵の弾

    // 敵の配列
    let enemies = [];
    let enemySpawnRate = 1000;
    let lastEnemySpawnTime = 0;

    // スコア
    let score = 0;

    // キー入力の状態を保持するオブジェクト
    const keys = {
        ArrowLeft: false,
        ArrowRight: false,
        Space: false,
        Enter: false // ★Enterキーを追加
    };

    // -----------------------------------------------------
    // 2. イベントリスナー（キー入力＆ボタン）
    // -----------------------------------------------------
    document.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.code)) {
            keys[e.code] = true;
        }

        // ★Enterキーで一時停止をトグル
        if (e.code === 'Enter' && !isGameOver) {
            isPaused = !isPaused;
        }
    });

    document.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) {
            keys[e.code] = false;
        }
    });

    // 一時停止ボタンのイベントリスナー
    pauseButton.addEventListener('click', () => {
        if (!isGameOver) {
            isPaused = !isPaused;
        }
    });

    // 自機の弾発射
    let lastShotTime = 0;
    const fireRate = 100;

    const fireBullet = (timestamp) => {
        if (keys.Space && timestamp - lastShotTime > fireRate) {
            const bullet = {
                x: player.x + player.width / 2 - 2.5,
                y: player.y,
                width: 5,
                height: 10,
                speed: 10
            };
            bullets.push(bullet);
            lastShotTime = timestamp;
        }
    };


    // -----------------------------------------------------
    // 3. 描画関数
    // -----------------------------------------------------

    // プレイヤーの描画
    const drawPlayer = () => {
        ctx.fillStyle = 'cyan';
        ctx.fillRect(player.x, player.y, player.width, player.height);
    };

    // 自機の弾丸の描画
    const drawBullets = () => {
        ctx.fillStyle = 'yellow';
        bullets.forEach(b => {
            ctx.fillRect(b.x, b.y, b.width, b.height);
        });
    };

    // ★敵の弾丸の描画
    const drawEnemyBullets = () => {
        ctx.fillStyle = 'magenta'; // 敵の弾はマゼンタ（ピンク）で区別
        enemyBullets.forEach(b => {
            ctx.fillRect(b.x, b.y, b.width, b.height);
        });
    };

    // 敵の描画
    const drawEnemies = () => {
        ctx.fillStyle = 'red';
        enemies.forEach(e => {
            ctx.fillRect(e.x, e.y, e.width, e.height);
        });
    };

    // スコアの描画
    const drawScore = () => {
        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`SCORE: ${score}`, 10, 30);
    };

    // 一時停止中の表示
    const drawPaused = () => {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
    }

    // ゲームオーバー画面の描画
    const drawGameOver = () => {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = '30px Arial';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 30);
    };


    // -----------------------------------------------------
    // 4. 更新関数
    // -----------------------------------------------------

    const updatePlayer = () => {
        if (keys.ArrowLeft) {
            player.x -= player.speed;
        }
        if (keys.ArrowRight) {
            player.x += player.speed;
        }
        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
    };

    const updateBullets = () => {
        bullets.forEach(b => {
            b.y -= b.speed;
        });
        bullets = bullets.filter(b => b.y + b.height > 0);
    };

    // ★敵の弾の位置を更新
    const updateEnemyBullets = () => {
        enemyBullets.forEach(b => {
            b.y += b.speed; // 下方向に移動
        });
        // 画面外に出た弾丸を削除
        enemyBullets = enemyBullets.filter(b => b.y < canvas.height);
    };

    // 敵の出現と位置を更新 (攻撃ロジックを含む)
    const updateEnemies = (timestamp) => {
        // 敵の生成
        if (timestamp - lastEnemySpawnTime > enemySpawnRate) {
            const enemy = {
                x: Math.random() * (canvas.width - 50),
                y: -50,
                width: 40,
                height: 40,
                speed: 1.5,
                lastShotTime: timestamp // 敵ごとの発射時間管理
            };
            enemies.push(enemy);
            lastEnemySpawnTime = timestamp;
            if (enemySpawnRate > 300) {
                 enemySpawnRate -= 5;
            }
        }

        // 敵の移動と攻撃
        enemies.forEach(e => {
            e.y += e.speed;

            // ★敵の攻撃ロジック (1/120の確率、または1秒に1回程度)
            if (Math.random() < 0.008 && timestamp - e.lastShotTime > 1000) {
                const enemyBullet = {
                    x: e.x + e.width / 2 - 2, // 敵の中央から発射
                    y: e.y + e.height,
                    width: 4,
                    height: 8,
                    speed: 5
                };
                enemyBullets.push(enemyBullet);
                e.lastShotTime = timestamp;
            }
        });

        // 画面下端に到達した敵
        enemies = enemies.filter(e => {
            if (e.y < canvas.height) {
                return true;
            } else {
                // 敵が画面外に出てもゲームオーバーにはせず、消えるようにする (難易度調整)
                // isGameOver = true; // ← この行をコメントアウトしました
                return false;
            }
        });
    };

    // 当たり判定 (AABB)
    const checkCollision = (rect1, rect2) => {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    };

    // 衝突判定の処理
    const handleCollisions = () => {
        // 1. 自機の弾と敵の衝突
        bullets.forEach((bullet, bIndex) => {
            enemies.forEach((enemy, eIndex) => {
                if (checkCollision(bullet, enemy)) {
                    bullets.splice(bIndex, 1);
                    enemies.splice(eIndex, 1);
                    score += 10;
                    return;
                }
            });
        });

        // 2. プレイヤーと敵の弾の衝突 (Player vs EnemyBullet)
        enemyBullets.forEach((eBullet, ebIndex) => {
            if (checkCollision(player, eBullet)) {
                isGameOver = true;
                enemyBullets.splice(ebIndex, 1); // 弾を削除
                return;
            }
        });

        // 3. プレイヤーと敵本体の衝突 (Player vs Enemy)
        enemies.forEach(enemy => {
            if (checkCollision(player, enemy)) {
                isGameOver = true;
            }
        });

        // 衝突により削除された要素でインデックスがずれる問題があるため、
        // 厳密にはループの後にフィルタリングで処理するのが望ましいですが、
        // シンプルな実装のためこの形を維持します。
    };


    // -----------------------------------------------------
    // 5. メインループ
    // -----------------------------------------------------

    const gameUpdate = (timestamp) => {
        if (isGameOver) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEnemies();
            drawEnemyBullets(); // 敵の残弾も描画
            drawPlayer();
            drawBullets();
            drawScore();
            drawGameOver();
            cancelAnimationFrame(gameLoop);
            return;
        }

        // 一時停止中
        if (isPaused) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEnemies();
            drawEnemyBullets();
            drawBullets();
            drawPlayer();
            drawScore();
            drawPaused();
            gameLoop = requestAnimationFrame(gameUpdate);
            return;
        }

        // 描画をクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 入力と状態の更新
        fireBullet(timestamp);
        updatePlayer();
        updateBullets();
        updateEnemyBullets(); // ★敵の弾を更新
        updateEnemies(timestamp);
        handleCollisions();

        // 描画
        drawEnemies();
        drawEnemyBullets(); // ★敵の弾を描画
        drawBullets();
        drawPlayer();
        drawScore();

        // 次のフレームを要求
        gameLoop = requestAnimationFrame(gameUpdate);
    };

    // ゲーム開始
    gameLoop = requestAnimationFrame(gameUpdate);
</script>

</body>
</html>
